import fs from 'node:fs';
import { execSync } from 'node:child_process';

const TYPES_TO_EXPORT = ['IconTheme', 'IconProps'];

const ICON_TEMPLATE_PATH = './src/lib/__template.svelte';
const ICON_SVELTE_PATH = './src/lib/heroicons';
const INDEX_PATH = './src/lib/index.ts';

const GIT_REPO = 'https://github.com/tailwindlabs/heroicons';
const GIT_TAG = 'v2.2.0';

const GIT_FOLDER = './heroicons';

const ICONS_SRC_PATHS = {
	micro: GIT_FOLDER + '/src/16/solid',
	mini: GIT_FOLDER + '/src/20/solid',
	solid: GIT_FOLDER + '/src/24/solid',
	outline: GIT_FOLDER + '/src/24/outline'
};

if (fs.existsSync(GIT_FOLDER)) {
	fs.rmSync(GIT_FOLDER, { recursive: true });
}

if (fs.existsSync(ICON_SVELTE_PATH)) {
	fs.rmSync(ICON_SVELTE_PATH, { recursive: true });
}
fs.mkdirSync(ICON_SVELTE_PATH);

if (fs.existsSync(INDEX_PATH)) {
	fs.rmSync(INDEX_PATH);
}

execSync(`git clone --depth 1 --branch ${GIT_TAG} ${GIT_REPO} ${GIT_FOLDER}`);

let iconData = {
	/*
    filename: {
        outline: '',
        // etc
    },
    */
};

for (const [theme, path] of Object.entries(ICONS_SRC_PATHS)) {
	if (!fs.existsSync(path)) {
		console.warn('Could not find source folder:', path, 'ignoring...');
		continue;
	}

	const files = fs.readdirSync(path);
	for (const filename of files) {
		if (!filename.endsWith('.svg')) continue;

		if (!iconData[filename]) {
			iconData[filename] = {
				outline: null,
				solid: null,
				mini: null,
				micro: null
			};
		}

		const icon = fs.readFileSync(`${path}/${filename}`, 'utf8');

		iconData[filename][theme] = icon;
	}
}

const TEMPLATE = fs.readFileSync(ICON_TEMPLATE_PATH, 'utf8');

const iconNames = {};

for (const [filename, icon] of Object.entries(iconData)) {
	const rawName = filename.replace('.svg', '');
	const svelteName =
		'Icon' +
		filename
			.replace('.svg', '')
			.split('-')
			.map((word) => word[0].toUpperCase() + word.slice(1))
			.join('');

	let iconSvelte = TEMPLATE.replace('%NAME%', rawName);
	for (const [theme, svg] of Object.entries(icon)) {
		if (!svg) {
			iconSvelte = iconSvelte.replace(`%${theme.toUpperCase()}_SVG%`, '<!-- Missing Icon -->');
			continue;
		}

		const propertyString = Object.entries({
			'data-type': 'svelte-heroicons',
			'data-icon': rawName,
			'data-theme': theme,
			'aria-hidden': 'true',
			class: '%class%',
			style: '%style%'
		})
			.map(([key, value]) => `${key}="${value}"`)
			.join(' ');

		const rewrittenSvg = svg //
			.replace(/<svg /, `<svg ${propertyString} `)
			.replaceAll(/black/g, 'currentColor')
			.replaceAll(/#0F172A/g, 'currentColor')
			.replaceAll(/#09090B/g, 'currentColor')
			.replaceAll(/#333333/g, 'currentColor');

		iconSvelte = iconSvelte.replace(`%${theme.toUpperCase()}_SVG%`, rewrittenSvg);
	}

	iconNames[rawName] = svelteName;
	fs.writeFileSync(`${ICON_SVELTE_PATH}/${svelteName}.svelte`, iconSvelte);
}

console.log('Wrote', Object.keys(iconNames).length, 'icons');

fs.writeFileSync(
	INDEX_PATH,
	[
		`// THIS FILE WAS AUTOMATICALLY GENERATED BY generate.js IN THE ROOT DIRECTORY. DO NOT EDIT.`,
		TYPES_TO_EXPORT.map((name) => `export type { ${name} } from '$lib/types.js';`).join('\n'),

		// Import the icons.
		Object.values(iconNames)
			.map((name) => `import ${name} from '$lib/heroicons/${name}.svelte';`)
			.join('\n'),

		// Export each icon svelte value.
		`export {\n\t${Object.values(iconNames).join(',\n\t')}\n};`,

		// Create a key:value mapping for each icon.
		`export const ICONS = {\n\t${Object.entries(iconNames)
			.map(([key, value]) => `"${key}": ${value}`)
			.join(',\n\t')}\n};`
	].join('\n\n')
);

console.log('Generated index.ts');
